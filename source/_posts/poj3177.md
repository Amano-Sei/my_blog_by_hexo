---
title: poj3177
cwd: hexo/myblog
date: 2020-11-02 12:47:20
mathjax: true
tags:
- 题解
- poj
- 边双连通
---

[Redundant Paths](http://poj.org/problem?id=3177)

题意其实就是问我们要在无向连通图中加多少条边使得图变成边双连通的。

因为边双连通分量其实和SCC很像，而且也有着自己的"根"，但是无向图中少了cross-link，所以使得我们可以不再用带栈的tarjan来做。

这部分很简单，说来也很奇怪，为什么我之前没有想过用并查集跑tarjan呢...实际考虑了下在SCC中用并查集可以避免用栈但是逃不掉bool数组（判断是否是当前点的祖先），而且如果需要多次缩点用栈会更方便一点。

将所有边双连通分量缩点后是第二部分。

**引理**: 对于树$T$，设其中度数为1的点个数为$m$，则可以通过添加$\lceil \dfrac\{m\}\{2\}\rceil$条边使得其变成边双连通图。

这部分我在网上找不到（我能理解的）证明，所以尝试着自己来证明。

首先插入一条结论，无向图中任意一个点从与他相连的任一条边出发一定可以到达一个度数为1的点，且从不同边出发到达的度数为1的点互不相同。
证明的话，直接强证也不是不行，不过我们可以借用[某个证明过的结论](/2020/10/30/poj1236/)变形。我们以这个点为根转化为根树，同时这也是我们从这个点开始的dfs搜索树。由证明过的结论他的每条出边都会到达某个叶子（对于原图度数为1的点，由于入度必不为0，入度为1，出度为0，即为叶子），并且由于没有cross-link，所以那个叶子一定在以出边终点为根的子树上，各个子树互不相交，即每个出边到达的某个叶子互不相同，自此证毕。

边双连通的图不会存在度数为1的点（因为使它度数为1的那条边就是割边），那么显然我们最少需要$\lceil \dfrac\{m\}\{2\}\rceil$条边来消除这些度数为1的点（一条边最多消除2个度数为1的点）。

接下来我们分情况来证明加这么多条边可以使得图变得边双连通。

没有度数为1的点，由于树的总度数为$2\(n\-1\)$，如果有2个以上的点，那么就不可能存在度数为0的点，则会有度数$2n\>2\(n\-1\)$。那么说明图中只有一个点，则不用加边，$0=\lceil \dfrac\{0\}\{2\}\rceil$。
只有1个度数为1的点，这是不可能的，因为树的总度数为$2\(n\-1\)$，有$\(n\-1\)$个点度数最少为2，再加上度数1就超过总度数了。

这里插入一条结论，连接树上的两个度数为1的点，会和两者之间路径上的边组成一个环，即组成一个边双连通分量，且没有在路径上的点不在这个边双连通分量中。我们可以把环上的点缩为一个点，缩成的点的度数就是整个环上的点度数减2的和，为了方便说明我们称这种建立在某两个度数为1的点上的和叫缩度。前半的正确性可以用tarjan的dfs搜索树证明，后半因为每个点都消除了环上与它相连的两条边的度数，所以缩度就是度数减2的和了。

有2个及以上度数为1的点。
假设对于有$\(m\-1\)$个度数为1的点的图，都有加$\lceil \dfrac\{m\-1\}\{2\}\rceil$条边使得图变成边双连通。
　　如果我们能找到缩度为2或以上的两个度数为1的点，那么我们连接这两个点，缩点，得到的新图中度数为1的点个数为$\(m\-2\)$，且我们已经加了1条边，由假设我们可以证明这个图加$1\+\lceil \dfrac\{m\-2\}\{2\}\rceil = \lceil \dfrac\{m\}\{2\}\rceil$条边可以使得它变得边双连通。
　　如果找不到上述这样的两点，那么说明任意2个度数为1的点之间的缩度为1或0，在这个大前提下，我们再分情况。
　　　　在存在最少一对缩度为1的两点，即两者之间的路径上存在一个度数为3的点，则从其不在路径上的边出发可以到达一个度数为1的点$v$。由于原本的两点与$v$的之间的两个缩度显然都大于等于1，由于只有0或1的缩度，所以只能为1。则与这些点所有相连的边都已经出现在从度数为3的点出发的三条路径上，如果还有其他的点会使得图失去连通性，所以所有的点都在图中，即只有3个度数为1的点，则我们任意加边缩点再加边得到了一个边双连通图，共加了$\lceil \dfrac\{3\}\{2\}\rceil = 2$条边。
　　　　在只存在缩度为0的度数为1的点对时，类似前面，与路径上的点相连的边都已经被遍历了，所以如果还有其他的点，就会使图失去连通性。那么图是2个度数为1的点之间的路径组成的，我们直接加边，图变成边双连通，共加了$1 = \lceil \dfrac\{2\}\{2\}\rceil$条边。

综上，我们证明了加$\lceil \dfrac\{m\}\{2\}\rceil$条边可以使得图变成边双连通图。又由最少要$\lceil \dfrac\{m\}\{2\}\rceil$条边，所以显然这么多条边就是最少的答案。

有了这些，我们可以轻易地写出代码，代码如下。

```cpp
/*************************************************************************
    > File Name: poj3177.cpp
    > Author: Amano Sei
    > Mail: amano_sei@outlook.com
    > Created Time: 2020年11月01日 星期日 20时55分25秒
 ************************************************************************/

#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
//虽然还没结束，并查集真好用...

const int maxn = 5005;
const int maxm = 20005;
struct Edge{
    int v, next;
}edge[maxm];
int head[maxn];
int pre[maxn];
int dfn[maxn], low[maxn];
int ci;
int deg[maxn];
bool book[maxm];

void dfs(int cu, int id){
    id ^= 1;
    dfn[cu] = low[cu] = ++ci;
    for(int i = head[cu]; i != -1; i = edge[i].next){
        int cv = edge[i].v;
        if(!dfn[cv]){
            dfs(cv, i);
            book[i] = true;
            low[cu] = min(low[cu], low[cv]);
        }else if(id != i)
            low[cu] = min(low[cu], dfn[cv]);
    }
    if(low[cu] != dfn[cu])
        pre[cu] = edge[id].v;
}

int getpre(int x){
    return pre[x]==-1?x:(pre[x]=getpre(pre[x]));
}

int main(){
    int n, m;
    int cu, cv;
    int ans = 0;
    scanf("%d%d", &n, &m);
    memset(head, -1, sizeof(head));
    memset(pre, -1, sizeof(pre));
    for(int i = 0; i < m; i++){
        scanf("%d%d", &cu, &cv);
        edge[i<<1] = { cv, head[cu] };
        head[cu] = i<<1;
        edge[i<<1|1] = { cu, head[cv] };
        head[cv] = i<<1|1;
    }
    dfs(1, -1);
    for(int i = 0; i < 2*m; i++)
        if(book[i]){
            cv = getpre(edge[i].v);
            cu = getpre(edge[i^1].v);
            if(cu != cv){
                deg[cu]++;
                deg[cv]++;
            }
        }
    for(int i = 1; i <= n; i++){
        if(pre[i] == -1 && deg[i] == 1)
            ans++;
    }
    printf("%d\n", (ans+1)/2);
    return 0;
}

```

最后再补充点自己想的额外的东西吧，森林的情况下，需要额外考虑度数为0的点，如果只有一个点且度数为0，显然不加边；如果有两个及以上的点，设度数为1的点个数为$p$，度数为0的点个数为$q$，显然最少要加$\lceil \dfrac\{p\+2q\}\{2\}\rceil$条边。然后是正确性证明，先消去非连通性，然后再内部连。先让0和0串成一串，加$\(q\-1\)$条边，这时还剩$\(p\+2\)$根度数为1的点，然后我们不同连通块之间连边，每次消去两个度数为1的点，最后是当作连通图来处理，最终加了$\lceil \dfrac\{p\+2\}\{2\}\rceil\+q\-1\ = \lceil \dfrac\{p\+2q\}\{2\}\rceil$条边，即得证。

