---
title: 其实自己二分的理解一直都有点问题...
cwd: hexo/myblog
date: 2020-11-01 22:08:40
mathjax: true
tags:
- 二分查找
- 思考
---

今天abc的e题再次又暴露了这个问题，第一时间自己还在想要不直接用lower\_bound函数吧（虽然自己还是在没有查资料的情况下自己写出来了，但是一直这样是不行的。

所以决定今天再次好好思考下这个问题，为什么我要说再次...

首先是最基本的二分，lower\_bound的实现。
```cpp
int lower_bound(int *val, int l, int r, int x){
    while(l <= r){
        int m = (l+r)>>1;
        if(val[m] < x)
            l = m+1;
        else
            r = m-1;
    }
    return l;
}
```
因为我一直在各种消灭自己的直觉，现在已经很难凭着直觉说我觉得他是正确的了，不过本来这里凭着直觉就不靠谱...所以我会用归纳看这个问题。
我们要证明结论是"我们要返回$\[l,r\]$中第一个大于等于他的数，如果没有则返回$r\+1$，对于答案在$\[l,r\+1\]$中的情况，函数在$\[l,r\]$上运行一定会正确返回结果"。

　　首先区间长度为1和2时的两种情况，验证得证。

　　假设当区间长度小于$n$时正确，接下来我们证明为$n$的情况。若有`val[m] < x`，只有当区间长度为1时才会有`m+1`不在原区间范围内，否则答案一定在$\[m\+1,r\+1\]$中且我们会得到一个长度小于n的区间$\[m+1, r\]$，由假设他会正确得到答案。若`val[m] >= x`，只有只有当区间长度为1或是2时才会有`m-1`不在原区间范围内，否则答案一定在$\[l,m\]$中且我们会得到一个小于n的区间$\[l,m\-1\]$，同样由假设正确。

这里的证明使得我们发觉，对于这样写的二分，我们只需要验证长度为1和2两种情况就可以了，后续的归纳是完全相同的。

类似的upper\_bound，只需要把条件改为`val[m] <= x`即可。

其实写着写着我就已经意识到了，我的误区很简单，就是因为二分的答案范围并不是$\[l,r\]$，而是$\[l,r\+1\]$，解决了这点，想必我以后不会再迷这样写的二分了吧。

