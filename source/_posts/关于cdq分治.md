---
title: 关于cdq分治
cwd: /home/amano-sei/hexo/myblog
date: 2020-12-06 15:24:53
mathjax: true
tags:
- 日常
- 思考
---

<details>
<summary>一些不太好的东西</summary>
没打算当作讲解写，因为网上已经有非常好的教程了，比如<a href="https://zhuanlan.zhihu.com/p/55322598">这篇</a>就很不错，而且这个本身并不复杂。

仅就我目前所理解的三维偏序来说点什么。用一句来概括cdq怎么做三维偏序，就是在分治排序第二维的过程中，不断计算左侧块中的元素对右侧块中的元素的贡献，而怎么计算，其实就是不断地做二维偏序。

对于数据范围为$k$，数据个数为$n$的数据，cdq分治能够把时间复杂度缩小，依赖于两点，分治排序把所有元素分成了$O\left\(\log n\right\)$层，每层的二维偏序能够在$O\left\(n\log k\right\)$时间里计算每个小的左侧块对右侧块的贡献。所以就有了$O\left\(n\log n\log k\right\)$的时间复杂度。

在cdq开始前的排序实质上做了两件事情，第一是保证满足后两维条件后左侧的元素一定对右侧的元素产生贡献，第二是保证所有可能对某个元素产生贡献的元素都能被排序至该元素的左侧，所以在允许相等的情况下我们要去重和不仅根据第一维排序。

说实话越想越觉得cdq分治有种简单粗暴的感觉，对于每个元素来说是用$O\left\(\log n\right\)$个二维偏序计算了它左侧所有的元素对他的贡献...

然后有一点关系不是很大的东西。就是如果排序和cdq过程中如果不是对完整的数据操作，而是对下标操作的话，直觉上来说因为移动的数据变少了所以可能变快。但是事实上在luogu上测试并不是这样，猜测是缓存导致的。
</details>

上面是一开始写的，但是看了[oi\-wiki](https://oi-wiki.org/misc/cdq-divide/)之后感觉自己之前的理解太肤浅了...而且背离了cdq分治的思想（...所以折叠吧，oi\-wiki上讲的挺好的...

说实话想收回前言，但是oi\-wiki上的思想讲的是真的好，虽然代码写的很迷...

然后还是那道例题[P3157 \[CQOI2011\]动态逆序对](https://www.luogu.com.cn/problem/P3157)，然后我们看下dalao写的[这份代码](https://www.luogu.com.cn/record/41054801)。

我自己第一次写的时候是跑了两次cdq来处理两种方向上的逆序对，然后还有两次循环，开两个树状数组等做法，这些做法本质都和两次cdq没有很大区别。但是那份代码不一样。

二维偏序的过程中我们存进树状数组的都是另一侧具有某种性质的元素，但是我们要找的范围可能不能简单地被包含在那种性质的元素中。类似这道题，我们可以让树状数组中都是数字小于剩余数字的元素，我们要找的是数小下标大和数大下标小的元素个数，我们可以直接找出数小下标大的数，然后我们提前减去数小下标小的个数，最后加上下标小的个数，就得到了我们要的那种性质的元素个数。

cdq和二维偏序密不可分，只要好好地理解树状数组中存的是什么就可以更加灵活地运用cdq。

