---
title: 一个简单的井字棋
cwd: /home/amano-sei/hexo/myblog
date: 2021-03-11 11:20:21
mathjax: true
tags:
- pn搜索
---

涉及的代码都在[这个github仓库](https://github.com/Amano-Sei/my-simple-tic-tac-toe)可以看到。因为所有代码加一起有点多，所以博客内就不会在列出代码了。

参考论文是Allis的[这篇](/pdf/SearchingForSolutions.pdf)[<sup>1</sup>](#refer)（荷兰人的英语太强了...（因为我语文很差，英语更差，做不到信达雅的意译，所以有些我不知道普遍接受的译名的东西会直接用英文上来）

好了进入正题，首先我们先来了解什么是pn搜索（即proof number search）。其实就是在一个and/or树上进行best first搜索的怎么取best的策略。

首先我们给出proof number和disproof number的定义，分别是最小证明集和最小证伪集的基。因为and/or树的特性，通过归纳我们可以证明对于树$T$总是存在同时属于的最小证明集和最小证伪集的frontier点$J$，当我们证明$J$时会使得$T$的proof number减1，证伪$J$时会使得$T$的disproof number减1，这样的点我们称之为$T$的most-proving点，也就是说选取这样的点并证明或证伪（事实上，通常不能直接证明或证伪）了它的话，总是可以让我们更加接近答案。

论文2\.3\.1中有提到，如果一个点被证明了或是证伪了，其对树的所有影响在更新祖先节点时就已经显现了出来，而在这之后的这个点就再也不会对树产生更多影响（用一种更直观的说法来说，就是具有$0, \infty$或是$\infty, 0$这样的proof number和disproof number的点如果不能使得他的父节点也变成$0, \infty$或是$\infty, 0$，那么这个点就不会在产生什么作用了（好像更绕了...

然后直接讲我的井字棋的实现，因为井字棋复杂度很低，而且比较简单，加上太久没写过像样的代码了，所以坚持决定写一下。

我们以当前棋盘为根（or点），然后一层and点一层or点这样进行搜索（很容易可以理解，只要我下在某个点就可以达成某个条件那么我一定可以达成，而对于对方不论对方下在任何地方都不能阻止我达成条件我才能保证一定达成）。先按照必胜进行搜索，搜索不到再按照不输进行搜索。如果证明了搜索树，那么我们就选中根的子节点中proof number为0的点对应的决策。因为井字棋一定不输，所以我没有准备必输的应对策略。

我用了论文2\.3\.2中的current点优化，原理就它都不变了，肯定它的祖先也不变，再选肯定还是它。因为most-proving点的定义，很容易误认为current点优化无意义（我开始是反过来的，以为most-proving点不一定存在，所以看论文的时候甚至觉得current点来的好...），但是事实上不是这样的，因为我们在选中frontier点时，不一定总是可以证明或是证伪，往往需要对点进行扩展，那么在不明确应用领域的情况下proof number和disproof number就可能获得任何值。

另外是节点总数，我们设剩余空白数为$n$，而我在造屎的时候误以为总数不超过$n!\+1$，而事实上是$\sum\limits\^\{n\}\_\{i=0\}\dfrac\{n\!\}\{i\!\}$（

重写的时候有个小插曲。因为之前造的屎是用的预准备好的节点池子，所以重写的时候换成了malloc，加上我忘记给棋盘赋值导致无限申请节点，直接内存爆炸死机了（一度怀疑过是不是malloc的效率不高，但是虽然存在碎片之类的问题导致内存利用率不高，以及效率不如直接申请一个大池子来的好，但是怎么也不可能会死机，居然怀疑malloc而不是第一时间想到死循环的我还是基础太差了QAQ

差不多就这么多...至于论文我才看到2\.3\.3的最后一小节，感觉佛系了...明明要准备考研，还花这么大气力看这个（而且不更努力下怕是交初稿前都看不完，但是就是迷之不慌...嘛，能直接写出实现说明我还不至于退步到两年前，继续加油看了（后面还有第3章和第5章，其他可以不看）

<div id="refer"></div>
- [1] Allis, Louis Victor. Searching for solutions in games and artificial intelligence. Wageningen: Ponsen & Looijen, 1994.

