---
title: 做了个倒计时
cwd: /home/amano-sei/hexo/myblog
date: 2021-02-22 09:57:56
mathjax: true
tags:
- 日常
---

（其实真正的起因是想把某些东西快点刷到第二页去，但是最近没什么好写的，只好写水到不能再水的东西了...）

起因是最近在算距离假定的考研那天的倒计时居然要跑到客厅去问小度...然后就想写个简单的小工具，最开始时我直接想到的是暴力枚举之间的每一天...但是这实在是太蠢了（我就想一定有个常数级别的做法...

思考后，得出了这样的做法: 先算出起始年份1月1日到终止年份1月1日的天数（我们通过算出到某年份各种数的倍数的个数，计算出到那一年一共有多少个闰年，然后我们对倒数第二年和第一年前一年的闰年数做差即可知道闰年数），最后再分别计算两端的天数加减即可。

最开始我是按照400年有97个闰年，不足400的逐个判断来做的，但是事实上3200的倍数只有172800的倍数是闰年（按照现在的回归年精度应该是最大的标准了），本来$O\left\(相差的年数\right\)$级别的问题降不降成常数就没啥意义，连比较大的年份都处理不了那也太逊了吧（所以改成了上面那种（事实上进一步降了常数（事实上我只是在水博客...

```c
/*************************************************************************
    > File Name: countdown.c
    > Author: Amano Sei
    > Mail: amano_sei@outlook.com
    > Created Time: 2021年02月22日 星期一 10时30分49秒
 ************************************************************************/

#include <stdio.h>

int mc[13] = { 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };

int pcnt(int x){
    return x/4-x/100+x/400-x/3200+x/172800;
}

int isp(int x){
    return x%172800 == 0 || (x%3200 != 0 && (x%400 == 0 || (x%100 != 0 && x%4 == 0)));
}

int main(int argc, char **argv){
    if(argc != 3){
        fprintf(stderr, "Usage: %s Y-M-D Y-M-D", argv[0]);
        return -1;
    }
    int sy, sm, sd;
    int ey, em, ed;
    sscanf(argv[1], "%d-%d-%d", &sy, &sm, &sd);
    sscanf(argv[2], "%d-%d-%d", &ey, &em, &ed);
    int ans = (ey-sy)*365+pcnt(ey-1)-pcnt(sy-1);

    mc[2] = isp(sy)?29:28;
    for(int i = 1; i < sm; i++)
        ans -= mc[i];
    ans -= sd-1;

    mc[2] = isp(ey)?29:28;
    for(int i = 1; i < em; i++)
        ans += mc[i];
    ans += ed-1;

    printf("从%s到%s有%d天\n", argv[1], argv[2], ans);

    return 0;
}

```

因为完全没有溢出之类的，以及完全是准备拿来自用的，所以没做很细致的数据检查。

