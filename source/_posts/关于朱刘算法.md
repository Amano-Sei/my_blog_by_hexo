---
title: 关于朱刘算法
cwd: hexo/myblog
date: 2020-10-22 11:11:21
mathjax: true
tags:
- 最小树形图
---

写在最前面，这里有用了有关tarjan的dfs论文中的知识，你可以去阅读[tarjan的论文](/pdf/tarjan.pdf)，或是来阅读[这篇博客](/2020/10/09/关于tarjan算法/)，主要是要知道cross-link和frond。

朱刘算法是用于解决有向图的最小生成树问题的算法，他的最差时间复杂度为$O\left\[|V|\left\(|V|\+|E|\right\)\right\]$（构造这样一个图，每轮只成一个两个点的环，类似下图）
![figure 1](/img/graph/zhuliu/figure1.jpg)

几乎所有的朱刘算法博客都有这么一张图，那我也放上来吧:
![figure 2](/img/graph/zhuliu/figure2.jpg)

理解这个算法我们需要引入几条小结论。

**命题1**: 有向图$G=\(V,E\)$，若除了一个点以外，每个点的入度都为$1$，且无环，那么$G$是一棵以入度为0的点为根的根树。
对这个有向图的逆跑dfs，因为无环，所以不会有frond，但是每个点如果入度不为0的话一定有一条入边，所以最终要么到达入度为0的点，要么止于一条cross-link。而cross-link指向的点的dfs的终止也是同样的，但是由于点是有限的，所以最终一定会指向入度为0的点，导致对于任意点来说存在一条从入度为0的点到该点的路径，即得证。

**命题2**: 有向图$G=\(V,E\)$，若除了一个点以外，每个点的入度都为$1$，若图$G$中有环，则只能形成简单环。
类似的我们还是在逆图上跑dfs，这里要么止于入度为0的点，要么止于cross-link或是frond，所以显然。

**命题3**: 如果点的最小入边形成了一个n个点的环，如果最小树形图存在那么一定存在一棵含有这个环中$\left\(n\-1\right\)$条边的最小树形图。
证明的话，已知环$C$是这样的一个环，设存在一棵最小树形图$T$，则$C$上离根最近的一个点$u$（可能有多个距离相同的点）的入边一定不在$T$中，否则就与我们对$u$的假设不符。
$u$的出边为$\left\(u,v\right\)$，如果$\left\(u,v\right\)$不在$T$上，我们可以把$\left\(u,v\right\)$插入$T$中，并删去$T$中$v$本来的入边，则会得到一个总权值不小于$T$的树形图，由于有$T$是最小树形图，所以有两者权值相等。重复上述操作，我们最终可以得到一棵具有$C$上$\(n\-1\)$条边的最小树形图。

**推论**: 对于朱刘算法中一轮中形成的SCC，若存在该图的最小树形图，则一定存在一棵最小树形图含有每个SCC去掉某一条边后的剩下的所有边。
借助一定是简单环，用类似命题3的证法，可以很容易地得出这个推论。

**命题4**: 朱刘算法会正确得出最小树形图的权值。
我们先来证明只需要一轮的情况下朱刘算法是正确的。
首先如果第一轮取最小入边没有环且除了根外每个点都有入边的情况下，由命题1我们得到了以根为根的权值最小的根树，显然正确。
如果存在有点没有入边，那么显然不可能有从根到该点的路径，那么显然不存在根树，更不可能存在最小树形图了。
如果在都有入边的情况下存在环的话，那么就说明我们需要一轮以上的朱刘算法。
至此我们可以证明只需要一轮朱刘算法的情况下，可以正确判断是否有最小树形图和得出最小树形图的权值。

接下来我们证明需要一轮以上的部分。
因为每轮朱刘算法，如果还要进行下去，必然是因为有环，而有环最小会合并两个顶点，加上朱刘算法在只有两个点的情况下一定会终止，所以朱刘算法一定会停下。
我们看最后的两轮，我们会发现，对于倒数第二轮中每个"含有每个SCC去掉某一条边后的剩下的所有边"（虽然很绕，但是我真的不知道怎么表达比较好）的根树一定与最后一轮中的每个根树一一对应（这是个双射），且倒数第二轮的根树的权值等于倒数第二轮得到的总权值（这是个常数）加上最后一轮的根树的权值。
如果最后一轮不存在根树（用前面的结论），那么自然倒数第二轮也不存在，进而可以用反证证明不存在最小树形图。
另一方面，如果存在，由推论一定存在一棵"含有每个SCC去掉一条边后的剩下的所有边"的最小树形图，所以我们可以由最后一轮的最小树形图对应出一棵倒数第二轮的最小树形图。
然后这个对应关系不仅仅在倒数第二轮和倒数第一轮之间存在，任何两个相邻的轮次之间都有着这样的双射关系。所以最终会得出对于最初的图是否有最小树形图，若有则可以得出它的权值。
（这里的证明是用了双射关系来做的，我表述的很莫名其妙，如果无法理解可以从双射的角度自己思考一下）

综上就这么多，关于细节上的实现，因为只需要判断是否是frond，所以微调了bin神的visit数组，下面是代码。

```cpp
const int inf = 0x3f3f3f3f;
const int maxn = 1005;
const int maxm = 40010;
struct Edge{
    int u, v, w;
}edge[maxm];
int pre[maxn], id[maxn], visit[maxn], in[maxn];
int zhuliu(int root, int n, int m){
    register int ans = 0;
    while(true){
        memset(in, 0x3f, sizeof(in));
        for(int i = 0; i < m; i++){
            register int cu = edge[i].u;
            register int cv = edge[i].v;
            register int cw = edge[i].w;
            if(cw < in[cv]){
                in[cv] = cw;
                pre[cv] = cu;
            }
        }
        in[root] = 0;
        for(int i = 0; i < n; i++)
            if(in[i] == inf)
                return -1;
        int tn = 0;
        memset(id, -1, sizeof(id));
        memset(visit, -1, sizeof(visit));
        for(int i = 0; i < n; i++){
            ans += in[i];
            register int cu = i;
            while(cu != root && visit[cu] == -1){
                visit[cu] = i;
                cu = pre[cu];
            }
            if(visit[cu] >= i){
                while(id[cu] == -1){
                    id[cu] = tn;
                    cu = pre[cu];
                }
                tn++;
            }
        }
        if(tn == 0)
            break;
        for(int i = 0; i < n; i++)
            if(id[i] == -1)
                id[i] = tn++;
        for(int i = 0; i < m;){
            register int cu = edge[i].u;
            register int cv = edge[i].v;
            if(id[cu] == id[cv])
                swap(edge[i], edge[--m]);
            else{
                edge[i] = { id[cu], id[cv], edge[i].w-in[cv] };
                i++;
            }
        }
        n = tn;
        root = id[root];
    }
    return ans;
}

```

貌似还有另一种最小树形图的算法，等下小憩一下，然后把剩下的题都a了，然后就去看（

